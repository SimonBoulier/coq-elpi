
accumulate lp-lib.
accumulate coq-lib.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Utilities %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% max X Y Z
%      i i o
type max int -> int -> int -> prop.
max X Y Y :-
    X < Y.
max X Y X :-
    not (X < Y).

%% same-root X Y
%            i i
% Resolves only if the two terms are application of the same function/constructor
type same-root term -> term -> prop.
same-root X X.
same-root X (app [Y|_]) :- same-root X Y.
same-root (app [X|_]) Y :- same-root X Y.

%% do-apply T Params Out
%           i i      o
% Do the beta reduction of app [T|Params] (only on Params, does not beta reduce
% T)
type do-apply term -> list term -> term -> prop.
do-apply (lam _ _ Bo) [T|Ts] Out :-
    do-apply (Bo T) Ts Out.
do-apply (prod _ _ Bo) [T|Ts] Out :-
    do-apply (Bo T) Ts Out.
do-apply Out [] Out.

%% flip Prop Out
%       i    o
% Same as Haskell's flip but for propositions
type flip (A -> B -> C -> prop) -> B -> A -> C -> prop.
flip F B A C :-
    F A B C.

%% mconst X Y Z
%         i i o
% (mconst j) is the proposition constant to j
type mconst A -> B -> A -> prop.
mconst X _ X.

%% repeat N X L
%         i i o
% Output the list of X repeated N times
repeat 0 X [].
repeat N X [X|L] :-
    N1 is N - 1,
    repeat N1 X L.

repeat-test :-
    (pi a\ repeat 42 a (Out a)),
    coq-say Out.

%% uncons-last L L' Last
%              i o  o
type uncons-last list A -> list A -> A -> prop.
uncons-last [] _ _ :-
    fatal-error "uncons-last used on empty list".
uncons-last L L' Last :-
    uncons-last-acc L [] L' Last.
uncons-last-acc [X] Acc L' X :-
    rev Acc L'.
uncons-last-acc [X|L] Acc L' Last :-
    uncons-last-acc L [X|Acc] L' Last.

%% unapply In (pr UnApp Arg)
%          i  o
% unapply takes an application and remove its last argument, returning it :
%   unapply In UnApp Arg => In =_\beta app [UnApp,Arg]
type unapply term -> pair term term -> prop.
unapply (app [X]) Out :-
    unapply X Out.
unapply (app [X,Y]) (pr X Y).
unapply (app [X|L]) (pr (app [X|L']) Arg) :-
    uncons-last L L' Arg.

%% split-app App (pr Fun Args)
%            i   o
% Takes applications (potentially nested) and identify the function and its
% list of arguments
split-app (app [X|L]) (pr Fun Args) :-
    split-app X (pr Fun Args'),
    append Args' L Args.
split-app X (pr X []).

%% get-type-information Tp Params Luno TY LC LT
%                       i  i      o    o  o  o
%   Tp     : a coq type potentially partially applied
%   Params : parameters for Tp
%   Luno   : number of uniform parameters
%   TY     : the type of app [Tp|Params]
%   LC     : the constructors of app [Tp|Params]
%   LT     : their types
get-type-information (app [X|Prs]) Params Luno TY LC LT :-
    append Prs Params Params',
    get-type-information X Params' Luno TY LC LT.
get-type-information (indt GR) Params Luno TY LC LT :-
    coq-env-indt GR tt _ Luno' TY' LC' LT',
    do-apply TY' Params TY,
    map LC' ((flip mk-app) Params) LC,
    map LT' ((flip do-apply) Params) LT,
    length Params L,
    Luno'' is Luno' - L,
    max Luno'' 0 Luno.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% API %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

type params  string -> int -> prop.
type phi     string -> term -> list term -> term -> term -> prop.
type doConst string -> term -> term -> term -> prop.
type doLeaf  string -> term -> term -> term -> term -> prop.
type doType  string -> term -> term -> term -> term -> term -> prop.
type doCon   string -> term -> term -> term -> term -> term -> term -> prop.
type doInl   string -> term -> term -> term -> term -> term -> prop.
type doInr   string -> term -> term -> term -> term -> term -> prop.
type doPair  string -> term -> term -> term -> term -> term -> term -> prop.
type doUnit  string -> term -> term -> prop.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%% Generics instance %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% make-rep LT Out
%           i  o
%   LT   : the types of its constructors
%   Out  : a type isomorph to Type expressed in terms of sums and products,
%          where every instances of Type are structurally smaller
make-rep [T|LT] (app [SumType, T1, T2]) :-
    make-rep-prod T  T1,
    make-rep      LT T2,
    coq-locate    "SumType" SumType.
make-rep [T] T' :-
    make-rep-prod T T'.

%% make-rep-prod T Out
%                i o
%   T    : the type of a constructor
%   Out  : a type isomorph to the constructor expressed in terms of products
make-rep-prod (lam N T Bo) Out :-
    make-rep-prod (prod N T Bo) Out.
make-rep-prod (prod _ T1 Bo) (app [ProdType, T1, T2]) :-
    coq-locate "ProdType" ProdType,
    (pi x\ make-rep-prod (Bo x) T2),
    coq-locate "UnitType" UnitType,
    not (T2 = UnitType).
make-rep-prod (prod _ T1 Bo) T1.
make-rep-prod _ UnitType :-
    coq-locate "UnitType" UnitType.

make-rep-test :-
    coq-locate "list" List,
    coq-locate "nat"  Nat,
    get-type-information List [Nat] _ _ _ LT, !,
    make-rep LT Out,
    coq-say Out.

%% make-f Type Out
%         i    o
make-f Type (lam "x" Type x\ (match x (lam "_" Type _\ hole) MTerms)) :-
    split-app Type (pr Head Args),
    length Args N,
    get-type-information Type [] _ _ LC LT,
    map2 LC LT (make-f-acc LC LT N []) MTerms.

make-f-acc LC LT N Acc C (prod Nm T Bo) (lam Nm T Out) :-
    pi x\ make-f-acc LC LT N [x|Acc] C (Bo x) (Out x).
make-f-acc LC LT N Acc C (lam Nm  T Bo) (lam Nm T Out) :-
    pi x\ make-f-acc LC LT N [x|Acc] C (Bo x) (Out x).
make-f-acc LC LT N Acc' C _ Out :-
    rev Acc' Acc,
    make-f-for-constructor LC LT (app [C|Acc]) N Out.

%% make-f-for-constructor LC LT X N Out
%         i  i  i i o
%   LC  : the constructors of the type we're working with
%   LT  : their types
%   X   : the term to abstract
%   N   : the number of iapplied parameters of the type
%   Out : X represented in (rep Type)
make-f-for-constructor LC' LT X N Out :-
    split-app X (pr C Args'),
    drop N Args' Args,
    map LC' split-app LC'',
    map LC'' fst LC,
    make-f-sum LC LT C Args Out.

make-f-sum [C|LC] [T|LT] C Args (app [{{MkSumL}}, T1, T2, Out]) :-
    make-rep-prod T T1,
    make-rep LT T2,
    make-f-prod T Args Out.
make-f-sum [C'|LC] [T|LT] C Args (app [{{MkSumR}}, T1, T2, Out]) :-
    make-rep-prod T T1,
    make-rep LT T2,
    make-f-sum LC LT C Args Out.
make-f-sum [C] [T] C Args Out :-
    make-f-prod T Args Out.

make-f-prod (lam N T Bo) Args Out :-
    make-f-prod (prod N T Bo) Args Out.
make-f-prod _ [X] X.
make-f-prod (prod _ T1 Bo) [X|Args] (app [{{MkProd}}, T1, T2, X, Out]) :-
    (pi x\ make-rep-prod (Bo x) T2),
    pi x\ make-f-prod (Bo x) Args Out.
make-f-prod _ [] {{MkUnit}}.

make-f-test :-
    coq-locate "list" List,
    coq-locate "nat"  Nat,
    make-f (app [List,Nat]) Out,
    coq-say Out,
    coq-elaborate Out Bo TBo,
    coq-say TBo.

%% make-g Type Out
%         i    o
make-g Type (lam "x" Rep Out) :-
    get-type-information Type [] _ _ LC LT,
    make-rep LT Rep,
    pi x\ make-g-sum LC LT x (Out x).

make-g-sum [C] [T] Rep Out :-
    make-g-prod C T [] Rep Out.
make-g-sum [C|LC] [T|LT] Rep
        (match Rep (lam "_" (app [SumType, T1, T2]) _\ hole)
            [ (lam "x" T1 HSumL)
            , (lam "x" T2 HSumR)
            ]) :-
    coq-locate "SumType" SumType,
    make-rep-prod T T1,
    make-rep LT T2,
    (pi x\ make-g-prod C T [] x (HSumL x)),
    pi x\ make-g-sum LC LT x (HSumR x).

make-g-prod C (lam N T Bo) Acc X Params :-
    make-g-prod C (prod N T Bo) Acc X Params.
make-g-prod C (prod _ T1 Bo) Acc X
        (match X (lam "_"(app [ProdType, T1, T2]) _\ hole)
            [ lam "x" T1 x\ lam "y" T2 y\ Out x y ]) :-
    coq-locate "ProdType" ProdType,
    (pi x\ make-rep-prod (Bo x) T2),
    coq-locate "UnitType" UnitType,
    not (T2 = UnitType),
    pi x y\ make-g-prod C (Bo y) [x|Acc] y (Out x y).
make-g-prod C (prod _ T _) Acc' X (app [C|Params]) :-
    rev [X|Acc'] Params.
make-g-prod C _ Acc' X (app [C|Params]) :-
    rev Acc' Params.

make-g-test :-
    coq-locate "list" List,
    coq-locate "nat"  Nat,
    make-g (app [List,Nat]) Out,
    coq-say Out,
    coq-elaborate Out Bo TBo,
    coq-say TBo.

list-nat-test :-
    coq-locate "list" List,
    coq-locate "nat"  Nat,
    make-f (app [List,Nat]) F,
    coq-elaborate F OF TF,
    coq-env-add-const "f_nat" OF TF _, !,
    make-g (app [List,Nat]) G,
    coq-elaborate G OG TG,
    coq-env-add-const "g_nat" OG TG _.

%% make-inj Type F G Out
%           i    i i o
make-inj Type F G (lam "x" Type x\ match x (lam "_" Type _\ hole) MTerms) :-
    get-type-information Type [] _ _ _ LT,
    map LT make-inj-projector MTerms.

make-inj-projector (lam N T Bo) Out :-
    make-inj-projector (prod N T Bo) Out.
make-inj-projector (prod N T Bo) (lam N T Out) :-
    pi x\ make-inj-projector (Bo x) (Out x).
make-inj-projector _ {{eq_refl}}.

make-inj-test :-
    coq-locate "list" List,
    coq-locate "nat"  Nat,
    (pi f g\ make-inj (app [List, Nat]) f g (Inj f g)),
    coq-say Inj.

%% make-surj Type F G Out
%            i    i i o
make-surj Type F G (lam "x" Rep Out) :-
    get-type-information Type [] _ _ _ LT,
    make-rep LT Rep,
    pi x\ make-surj-aux Rep x (Out x).

make-surj-aux Rep X (match X (lam "_" Rep _\ hole)
        [ lam "a" T1 ML
        , lam "b" T2 MR
        ]) :-
    coq-locate "SumType" SumType,
    split-app Rep (pr SumType [T1, T2]), !,
    (pi x\ make-surj-aux T1 x (ML x)),
    (pi x\ make-surj-aux T2 x (MR x)).
make-surj-aux Rep X (match X (lam "_" Rep _\ hole)
        [ lam "a" T1 a\ lam "b" T2 Out ] ) :-
    coq-locate "ProdType" ProdType,
    split-app Rep (pr ProdType [T1, T2]), !,
    pi x\ make-surj-aux T2 x (Out x).
make-surj-aux UnitType X (match X (lam "_" UnitType _\ hole) [ {{eq_refl}} ]) :-
    coq-locate "UnitType" UnitType.
make-surj-aux _ _ {{eq_refl}}.

make-surj-test :-
    coq-locate "list" List,
    coq-locate "nat"  Nat,
    (pi f g\ make-surj (app [List, Nat]) f g (Surj f g)),
    coq-say Surj.

%% derive-generics Name
%                  i
derive-generics Name :-
    coq-locate Name Type,
    get-type-information Type [] _ TY _ _,
    derive-generics-acc Name Type [] TY CS,
    coq-elaborate CS Bo TBo,
    NOut is Name ^ "_generics",
    coq-env-add-const NOut Bo TBo GOut,
    GOut = const GR,
    coq-CS-declare-instance GR.

derive-generics-acc Name Type Params (prod N T Bo) Out :-
    derive-generics-acc Name Type Params (lam N T Bo) Out.
derive-generics-acc Name Type Params (lam N T Bo) (lam N T Out) :-
    pi x\ derive-generics-acc Name Type [x|Params] (Bo x) (Out x).
derive-generics-acc Name Type Params' _ 
        (app [{{Generics.Pack}}, app [Type|Params],
            app [{{Generics.Class}}, Rep, F, G, Inj, Surj]
        ])
        :-
    rev Params' Params,
    get-type-information Type Params _ _ _ LT,
    make-rep LT Rep,
    make-f (app [Type|Params]) F,
    make-g (app [Type|Params]) G,
    make-inj (app [Type|Params]) F G Inj,
    make-surj (app [Type|Params]) F G Surj.

