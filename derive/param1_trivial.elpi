/* param1 holds on the full type                                             */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

namespace derive.param1.trivial {

drop-last [_] [] :- !.
drop-last [X|XS] [X|YS] :- drop-last XS YS.

prove-args [] [] [].
prove-args [X,PX|Rest] [TX,TPX_X|TRest] [X,P1,PX,P2|PRest] :-
  safe-dest-app TPX_X HD ARGS,
  drop-last ARGS ARG,
  mk-app HD ARG TPX,
  param1-trivial-db TPX P, !,
  P1 = {{ lib:elpi.trivial_full lp:TX lp:TPX lp:P lp:X }},
  P2 = {{ lib:elpi.trivial_uniq lp:TX lp:TPX lp:P lp:X lp:PX }},
  prove-args Rest TRest PRest.

oty IsT W _ [Idx,V] _ {{ @Coq.Init.Logic.eq lp:Ty lp:Wx lp:V }} :-
  Ty = app[IsT,Idx], Wx = app[W,Idx].

body _ _ K (app _) V VT R :-
  safe-dest-app K Kname Params,
  assert (param1-congr-db Kname CongrK) "run derive.param1.congr first",
  mk-app CongrK Params Rhd,
  prove-args V VT P,
  mk-app Rhd P R.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
pred body-params
  i:int,   % number of params left
  i:term,  % inductive type applied to parameters treated so far
  i:term,  % inhabitation witness applied to parameters treated so far
  i:term,  % inductive type arity to process
  o:term.

body-params 0 IsT W (prod _ T _\ sort _) R :- !,
  R = {{ fun x : lp:T =>
          lib:elpi.contracts lp:T lp:IsT x (lp:W x) (lp:U x) }},
    U = {{ fix IH (x : lp:T) (y : lp:IsT x) {struct y} :
                @Coq.Init.Logic.eq (lp:IsT x) (lp:W x) y := lp:(Bo IH x y) }},
    @pi-decl `IH` {{ forall (x : lp:T) (y : lp:IsT x),
                @Coq.Init.Logic.eq (lp:IsT x) (lp:W x) y }} ih\ 
    @pi-decl `x` T x\
    @pi-decl `y` (app[IsT,x]) y\
      param1-trivial-db IsT {{ fun x : lp:T =>
          lib:elpi.contracts lp:T lp:IsT x (lp:W x) (lp:ih x) }} =>
      build-match y (app[IsT,x]) (oty IsT W) (body IsT W) (Bo ih x y)
  .
  
% param1 have the form : isT A (P : A -> Type) .. , so we process two
% binders at a time and we assume (H : trivial P) for each A and P
body-params N T W (prod A TA a\ prod P (TP a) (F a)) R :- N > 0, !,
  M is N - 2,
  R = (lam A TA a\
        lam P (TP a) p\
         lam _ {{ lib:elpi.trivial lp:a lp:p }} pf\ Bo a p pf), 
  @pi-decl A TA a\
  @pi-decl P (TP a) p\
  @pi-decl _ {{ lib:elpi.trivial lp:a lp:p }} pf\
    reali a p =>
    param1-trivial-db p pf => % to prove (P x) use (H x)
      body-params M {mk-app T [a,p]}
         {mk-app W [a,p,{{ lib:elpi.trivial_full lp:a lp:p lp:pf }} ]} (F a p) (Bo a p pf).

body-params _ T _ _ _ :-
  coq.say "derive.param1P: wrong shape " {coq.term->string T}
            ". It does not look like a unary parametricity translation of an inductive with no indexes.",
  fail.

main (indt GR) Suffix Clause :- do! [
  coq.env.indt GR _ Lno _ Arity _ _,
  assert (param1-inhab-db (indt GR) Witness) "run derive.param1.inhab first",
  body-params Lno (indt GR) Witness Arity R,
 % coq.say {coq.term->string R},
  coq.typecheck R RT,
  Name is {coq.gr->id GR} ^ Suffix,
  coq.env.add-const Name R RT ff Cst,
  Clause  = (param1-trivial-db (indt GR) Cst),
  coq.elpi.accumulate "derive.param1.trivial.db" (clause _ _ Clause)

].

}

% main IsT Prefix [ClauseW] :- do! [
%   % The input is T is the param1 translation of an inductive type
%   assert (IsT = indt GR) "derive.param1P: not an inductive type",
%   Name_aux is Prefix ^ {coq.gr->id GR} ^ "_witness",
%   Name is Prefix ^ {coq.gr->id GR},
%   
%   inhab.main GR Name_aux W,
%   ClauseW = (param1P-db IsT W),
%   coq.elpi.accumulate "derive.param1P.db" (clause _ _ ClauseW),
% 
%   congr.main GR ClausesCongr,
%   forall ClausesCongr
%     (x\ coq.elpi.accumulate "derive.param1P.db" (clause _ _ x)),
%   (
%   (ClauseW => ClausesCongr => unique.main GR Name W Cst,
%   Clause  = (param1P-db-trivial IsT Cst),
%   coq.elpi.accumulate "derive.param1P.db" (clause _ _ Clause) ) ; fail )
% ].
% 
% }

% vim:set ft=lprolog spelllang=:
