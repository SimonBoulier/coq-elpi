/* induction principles                                                      */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

namespace derive.induction {


% we cut since copy generates many solutions
pred subst i:term, o:term.
subst A B :- copy A B, !.

% local db associating to each constructor the hypothesis to be used
type induction-hyp-db term -> term -> prop.

% prove H G P finds a P : H => G
pred prove i:term, i:term, o:term.
prove H G P :- map-db H G P.

% prove-arg AppliedHyp AppliedGoal Argument ProofAppliedHyp Proof.
pred prove-arg i:term, i:term, i:term, i:term, o:term.

prove-arg X X _ P P :- !.

prove-arg (app [H|Hs]) (app[G|Gs]) X PHX PGX :-
  appendR HArgs [X] Hs, mk-app H HArgs Hyp,
  appendR GArgs [X] Gs, mk-app G GArgs Goal,
  prove Hyp Goal Proof,
  unwind {hd-beta Proof [X,PHX]} PGX.

prove-arg (prod _ X x\ prod _ (PX x) (H x)) (prod _ Y y\ prod _ (PX y) (G y)) A PA (lam `x` X x\ lam `px` (PX x) (Proof x)) :- 
  pi x px\
    prove-arg (H x px) (G x px) {mk-app A [x]} {mk-app PA [x,px]} (Proof x px).
 
pred prove-args i:list term, i:list term, o:list term.
prove-args [] [] [].
prove-args [X,Pr|Args] [_,PX|ArgsT] [X,Proof|QArgs] :-
  subst PX Goal,
  prove-arg PX Goal X Pr Proof, !,
  prove-args Args ArgsT QArgs.  

% create (map-db (is_T params) P IH)
mk-map-isT-P-clause [_] T P IH (map-db T P IH).

mk-map-isT-P-clause [_,_|Args] T P IH (pi x y\ C x y) :-
  pi x y\ mk-map-isT-P-clause Args {mk-app T [x,y]} {mk-app P [x,y]} {mk-app IH [x,y]} (C x y).

% branch for constructor k is (hyp-k ...) where ... are the terms
% generated by prove-args
branch K _ V VT R :-
  induction-hyp-db K IH,
  prove-args V VT Args,
  mk-app IH Args R,
  coq.typecheck R _, !.

oty _ _ VT P :-
  last VT XT,
  subst XT P.

branches (prod Name S T) Ity Args IH N M (prod Name S F1) (lam Name S R1) :- !,
  @pi-decl Name S x\
    branches (T x) Ity [x|Args] IH {calc (N + 1)} M (F1 x) (R1 x).

branches (sort _) Ity Args IH Rno Rno Fty (lam `x` ItyArgs Bo) :- do! [
  mk-app Ity {rev Args} ItyArgs,
  subst ItyArgs PArgs,
  Fty = prod `x` ItyArgs (_\ PArgs),
  subst Ity P,
  mk-map-isT-P-clause Args Ity P IH C,
  @pi-decl `x` ItyArgs x\
    C =>
    build-match x ItyArgs oty branch (Bo x)
].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Synthesize the type of each hypothesis starting from the type
% of the constructor of is_T

hyp (prod N S T) (prod N Q R) :- !,
  subst S Q,
  @pi-decl N Q x\ hyp (T x) (R x).
hyp S Q :- subst S Q.

hyps [K|KS] [KT|KTS] Ity Arity (lam Name Ind Bo) :-
  term->gr K GRK,
  coq.name-suffix `H` {coq.gr->id GRK} Name,
  hyp KT Ind, !, % we cut since copy generates many solutions
  @pi-decl `Name` Ind x\
    induction-hyp-db K x => % This is the hyp to be used for branch K
    hyps KS KTS Ity Arity (Bo x).

hyps [] [] Ity Arity (fix `IH` Recno Fty Bo) :-
  @pi-decl `IH` Fty f\ sigma C\
    branches Arity Ity [] f 0 Recno Fty (Bo f).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parameters and the P of the induction predicate (truncated wrt the type
% of the unary parametricity translation, eg P takes only the indexes)

truncated-predicate-ty (sort _) T :-
  T = sort (typ U), coq.univ.new [] U.
truncated-predicate-ty (prod N S T) (prod N S R) :-
  pi x\ truncated-predicate-ty (T x) (R x).
  
% loads the context with the substitution "is_T params -> P"
mk-subst-clause Ity P C :-
 safe-dest-app Ity IT ITArgs,
 C = [(copy IT P :- !),
      (pi Args Rest O\
        copy (app[IT|Args]) O :- !, appendR ITArgs Rest Args, mk-app P Rest O)].

params N Ity K KT (prod Nx Sx x\ prod NP (SP x) (T x)) (lam Nx Sx x\ lam NP (SP x) (R1 x)) :- N > 0, !,
  M is N - 2,
  @pi-decl Nx Sx x\
  @pi-decl NP (SP x) px\
    % useless, the identity map is already there
    % map-db px px (lam `x` x a\ lam `pa` (app[px,a]) pa\ pa) =>
    params M
      {mk-app Ity [x,px]}
      {map K (k\ mk-app k [x,px])}
      {map KT (subst-prod [x,px])}
      (T x px) (R1 x px).

params 0 Ity K KT Arity (lam `P` Pty p\ Bo p) :-
  % P only takes the indexes of Arity
  truncated-predicate-ty Arity Pty,
  @pi-decl `P` Pty p\ sigma Subst\
    (mk-subst-clause Ity p Subst,
     % replace (is_T params) with P
     Subst =>
       hyps K KT Ity Arity (Bo p)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% mainly to infer universe constraints, since the kernel does not
% infer anymore :-(
ensure-typechecks R RT :- coq.typecheck R RT, !.
ensure-typechecks R _ :-
  coq.error "derive.induction: Generate ill-typed term:" {coq.term->string R}.

pred main i:term, i:string, o:list prop.
main T Name [Clause] :- do! [
  assert (T = indt _) "derive.induction: not an inductive type",
  assert (reali T TR) {calc (
    "derive.induction: no unary parametricity translation for" ^
    {coq.term->string T} ^ ", use derive.param1 first")},
  TR = indt GRR,
  coq.env.indt GRR Ind Lno _ Arity K KT,
  assert (Ind = tt) "derive.induction: Coinductive types are not supported",

  % we build the induction principle
  params Lno TR K KT Arity R,
  ensure-typechecks R RT,
  coq.env.add-const Name R RT _ I,

  % we register it as a clause
  Clause = (induction-db T I :- !),
  coq.elpi.accumulate "derive.induction.db" (clause _ (before "induction-db:fail") Clause)
].

}
